// 考虑到结果只有两种，要么Alice获胜要么Bob，Alice获胜的情况更少，所以只考虑Alice获胜的情况。
// 由于需要考虑移出的石子的价值之和能否被3整除，那么只要考虑石子价值对3的模。
// Alice获胜的话，必然不能先取0（x%3==0）。
// 先不考虑Alice或Bob中途取0。
// 假设先取1（x%3==1），相应地，Bob就只能也取1（sum=2）而Alice就只能取2（sum=(2+2)%3=1）。依此类推，取石子的顺序为1, 1, 2, 1, 2, ... 直到1或者2之一消耗完。
// 假如先取2（x%3==2），类似可以得出顺序为2, 2, 1, 2, 1, ...。
// 再把0考虑进去，因为0不影响和的模，所以可以把0插入非起始的任意位置。若Alice中途某次取0，则Bob也可以针对性地取0，这样又回到了Alice的回合。所以0的数量模2的结果为0还是1才会影响结果。

// 再回头继续考虑先取1的情况。
// Alice获胜的话，序列应该是

// 1, (1, 2, 1, 2, ..., 1, 2,), 2
// （其中，cnt[0] % 2 == 0, cnt[1] = k + 1, cnt[2] >= k + 1）
// 1, (1, 2, 1, 2, ..., 1, 2,) 1, 0, 1
// （其中，cnt[0] % 2 == 1, cnt[1] >= k + 3, cnt[2] = k）
// 括号中为k对1和2的组合，k >= 0。
// 故cnt[0] % 2 == 0时，胜利条件为cnt[1] >= 1, cnt[2] >= cnt[1] >= 1
// cnt[0] % 2 == 1时，胜利条件为cnt[1] - cnt[2] >= 3。

// 先取2的情况可以根据对称性得出。
// 综合两种情况，胜利条件为(cnt[0] % 2 == 0 && cnt[1] * cnt[2] > 0) || (cnt[0] % 2 == 1 && abs(cnt[1] - cnt[2]) >= 3)

/**
 * @param {number[]} stones
 * @return {boolean}
 */
 var stoneGameIX = function(stones) {
    let cnt0 = 0, cnt1 = 0, cnt2 = 0;
    stones.forEach(item => {
        if (item % 3 === 0) {
            cnt0 += 1;
        }
        else if (item % 3 === 1) {
            cnt1 += 1;
        } else {
            cnt2 += 1;
        }
    });
    if (cnt0 % 2 === 0 && cnt1 * cnt2 > 0) {
        return true;
    }
    if (cnt0 % 2 === 1 && Math.abs(cnt1 - cnt2) >= 3) {
        return true;
    }
    return false;
};
